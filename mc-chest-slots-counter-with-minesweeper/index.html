<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>chest gui with minesweeper</title>
<link rel="icon" type="image/png" href="https://static.miraheze.org/btawiki/b/b8/Wooden_Chest.png">
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    background: #1a1a1a;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    font-family: monospace;
    padding: 12px;
    touch-action: manipulation;
  }

  .chest-wrapper {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 100%;
    max-width: 400px;
  }

  .tabs {
    display: flex;
    align-self: flex-start;
    gap: 0;
    margin-left: 4px;
  }

  .tab {
    background: #aaaaaa;
    border-top: 3px solid #dddddd;
    border-left: 3px solid #dddddd;
    border-right: 3px solid #444;
    border-bottom: none;
    padding: 5px 14px 4px;
    cursor: pointer;
    font-size: 12px;
    font-weight: bold;
    color: #555;
    font-family: 'Segoe UI', sans-serif;
    user-select: none;
    margin-right: 2px;
    -webkit-tap-highlight-color: transparent;
  }

  .tab.active {
    background: #c6c6c6;
    border-top: 3px solid #ffffff;
    border-left: 3px solid #ffffff;
    border-right: 3px solid #555;
    border-bottom: none;
    color: #222;
    position: relative;
    z-index: 1;
  }

  .tab:hover:not(.active) { background: #bbbbbb; }

  .chest-container {
    background: #c6c6c6;
    border-top: 3px solid #ffffff;
    border-left: 3px solid #ffffff;
    border-right: 3px solid #555555;
    border-bottom: 3px solid #555555;
    padding: 10px;
    display: flex;
    flex-direction: column;
    gap: 2px;
    width: 100%;
  }

  .section-label {
    font-size: 11px;
    color: #3f3f3f;
    margin: 4px 2px 2px;
    font-family: 'Segoe UI', sans-serif;
    font-weight: bold;
  }

  /* ---- TOP CHEST GRID ---- */
  .grid {
    display: grid;
    gap: 2px;
  }

  .slot {
    width: var(--cell);
    height: var(--cell);
    background: #8b8b8b;
    border-top: 2px solid #373737;
    border-left: 2px solid #373737;
    border-right: 2px solid #ffffff;
    border-bottom: 2px solid #ffffff;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 10px;
    font-weight: bold;
    color: #ffffff;
    text-shadow: 1px 1px 0px #000000aa;
    cursor: pointer;
    transition: background 0.1s;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
  }

  .slot:hover { background: #9e9e9e; }

  .slot.selected {
    background: #5a8a5a;
    border-top: 2px solid #2a5a2a;
    border-left: 2px solid #2a5a2a;
    border-right: 2px solid #90ee90;
    border-bottom: 2px solid #90ee90;
  }

  .slot.selected:hover { background: #6a9a6a; }

  .divider {
    height: 4px;
    background: #8b8b8b;
    border-top: 2px solid #373737;
    border-bottom: 2px solid #ffffff;
    margin: 4px 0;
  }

  /* ---- MINESWEEPER GRID ---- */
  .ms-grid {
    display: grid;
    grid-template-columns: repeat(9, var(--cell));
    gap: 2px;
    touch-action: none;
  }

  .ms-cell {
    width: var(--cell);
    height: var(--cell);
    background: #8b8b8b;
    border-top: 2px solid #ffffff;
    border-left: 2px solid #ffffff;
    border-right: 2px solid #373737;
    border-bottom: 2px solid #373737;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: clamp(12px, 3.5vw, 17px);
    font-weight: bold;
    cursor: pointer;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
    transition: background 0.05s;
    font-family: monospace;
    position: relative;
    overflow: hidden;
  }

  .ms-cell.hidden { cursor: pointer; }
  .ms-cell.hidden:hover { background: #9e9e9e; }

  /* Long-press charging ring ‚Äî color = action that will fire */
  .ms-cell.pressing::after {
    content: '';
    position: absolute;
    inset: 2px;
    border-radius: 50%;
    border: 3px solid #4db8e8; /* default: flag blue */
    animation: presscharge 0.5s linear forwards;
    pointer-events: none;
  }
  /* In flag mode, long-press = dig, so ring is green */
  .ms-grid.flag-mode .ms-cell.pressing::after {
    border-color: #7ab87a;
  }

  @keyframes presscharge {
    0%   { opacity: 0.3; transform: scale(0.5); }
    100% { opacity: 1;   transform: scale(1); }
  }

  .ms-cell.revealed {
    background: #a0a0a0;
    border: 1px solid #888;
    cursor: default;
  }

  .ms-cell.flagged {
    background: #1a6b9a;
    border-top: 2px solid #4db8e8;
    border-left: 2px solid #4db8e8;
    border-right: 2px solid #0a3a5a;
    border-bottom: 2px solid #0a3a5a;
  }

  .ms-cell.mine-hit {
    background: #cc3333;
    border: 2px solid #ff5555;
  }

  .ms-cell.mine-revealed {
    background: #a0a0a0;
    border: 1px solid #888;
  }

  .n1 { color: #1111cc; }
  .n2 { color: #117711; }
  .n3 { color: #cc1111; }
  .n4 { color: #111177; }
  .n5 { color: #771111; }
  .n6 { color: #117777; }
  .n7 { color: #111111; }
  .n8 { color: #777777; }

  .ms-hud {
    display: flex;
    align-items: center;
    justify-content: space-between;
    background: #c6c6c6;
    border-top: 2px solid #ffffff;
    border-left: 2px solid #ffffff;
    border-right: 2px solid #555;
    border-bottom: 2px solid #555;
    padding: 4px 8px;
    margin-bottom: 2px;
  }

  .ms-counter {
    background: #000;
    color: #ff2222;
    font-family: 'Courier New', monospace;
    font-size: 18px;
    font-weight: bold;
    padding: 2px 6px;
    border-top: 2px solid #555;
    border-left: 2px solid #555;
    border-right: 2px solid #ffffff;
    border-bottom: 2px solid #ffffff;
    min-width: 40px;
    text-align: center;
    letter-spacing: 2px;
  }

  .ms-face-btn {
    min-width: 32px;
    height: 32px;
    padding: 0 6px;
    background: #c6c6c6;
    border-top: 3px solid #ffffff;
    border-left: 3px solid #ffffff;
    border-right: 3px solid #555;
    border-bottom: 3px solid #555;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 13px;
    cursor: pointer;
    user-select: none;
    white-space: nowrap;
    -webkit-tap-highlight-color: transparent;
  }

  .ms-face-btn:active {
    border-top: 3px solid #555;
    border-left: 3px solid #555;
    border-right: 3px solid #ffffff;
    border-bottom: 3px solid #ffffff;
  }

  /* ---- TOOL SWITCHER ---- */
  .tool-switcher {
    display: flex;
    gap: 4px;
    margin: 5px 2px 3px;
    align-items: center;
  }

  .tool-btn {
    display: flex;
    align-items: center;
    gap: 5px;
    padding: 4px 10px;
    font-size: 12px;
    font-family: 'Segoe UI', sans-serif;
    font-weight: bold;
    cursor: pointer;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
    background: #aaaaaa;
    border-top: 3px solid #dddddd;
    border-left: 3px solid #dddddd;
    border-right: 3px solid #444444;
    border-bottom: 3px solid #444444;
    color: #444;
    transition: background 0.08s;
    white-space: nowrap;
  }

  .tool-btn.active-dig {
    background: #7ab87a;
    border-top: 3px solid #333;
    border-left: 3px solid #333;
    border-right: 3px solid #aff5af;
    border-bottom: 3px solid #aff5af;
    color: #1a3d1a;
  }

  .tool-btn.active-flag {
    background: #1a6b9a;
    border-top: 3px solid #333;
    border-left: 3px solid #333;
    border-right: 3px solid #4db8e8;
    border-bottom: 3px solid #4db8e8;
    color: #d0f0ff;
  }

  .tool-btn:not(.active-dig):not(.active-flag):hover { background: #bbbbbb; }

  /* In flag mode, tint hidden cells blue so it's obvious */
  .ms-grid.flag-mode .ms-cell.hidden {
    background: #7a9ab0;
  }
  .ms-grid.flag-mode .ms-cell.hidden:hover {
    background: #8ab0c8;
  }

  .selected-display {
    margin-top: 12px;
    background: #111;
    border: 1px solid #333;
    border-radius: 4px;
    padding: 7px 14px;
    color: #aaffaa;
    font-size: 11px;
    max-width: 400px;
    width: 100%;
    word-break: break-all;
    text-align: center;
  }

  .clear-btn {
    margin-top: 6px;
    background: #3a3a3a;
    color: #ccc;
    border: 1px solid #555;
    border-radius: 3px;
    padding: 6px 18px;
    font-size: 11px;
    cursor: pointer;
    font-family: monospace;
    -webkit-tap-highlight-color: transparent;
  }
  .clear-btn:hover { background: #555; color: #fff; }
</style>
</head>
<body>

<div class="chest-wrapper">
  <div class="tabs">
    <div class="tab active" id="tab-large" onclick="switchTab('large')">Large Chest</div>
    <div class="tab" id="tab-small" onclick="switchTab('small')">Small Chest</div>
    <div class="tab" id="tab-hopper" onclick="switchTab('hopper')">Hopper</div>
  </div>
  <div class="chest-container">

    <div class="section-label" id="chest-label">Large Chest</div>
    <div class="grid" id="chest-grid"></div>

    <div class="divider"></div>

    <div class="ms-hud" style="width:100%">
      <div class="ms-counter" id="mine-counter">12</div>
      <div class="ms-face-btn" id="face-btn" onclick="resetGame()" title="New Game">(‚ïπ⁄°‚ïπ )</div>
      <div class="ms-counter" id="timer-display">000</div>
    </div>

    <div class="section-label">Inventory</div>
    <div class="tool-switcher">
      <div class="tool-btn active-dig" id="tool-dig" onclick="setTool('dig')">&#9935; Dig</div>
      <div class="tool-btn" id="tool-flag" onclick="setTool('flag')">&#128681; Flag</div>
      <span class="tool-label" id="tool-hint">tap to dig ¬∑ hold/right-click to flag</span>
    </div>
    <div class="ms-grid" id="ms-grid"></div>

    <div style="height:4px"></div>
    <div class="grid" id="hotbar-grid"></div>

  </div>
</div>

<div class="selected-display" id="selected-label">Selected chest slots: none</div>
<button class="clear-btn" onclick="clearChestSelection()">Clear Selection</button>

<script>
  // ‚îÄ‚îÄ‚îÄ RESPONSIVE CELL SIZE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  function setCellSize() {
    // 9 cells + 8*2px gaps + 2*10px padding + 2*3px border = 9c + 42
    const maxW = Math.min(window.innerWidth - 24, 400);
    const cell = Math.max(28, Math.min(Math.floor((maxW - 42) / 9), 40));
    document.documentElement.style.setProperty('--cell', cell + 'px');
  }
  setCellSize();
  window.addEventListener('resize', setCellSize);

  // ‚îÄ‚îÄ‚îÄ AUDIO ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  let audioCtx = null;
  function getCtx() {
    if (!audioCtx) audioCtx = new AudioCtx();
    if (audioCtx.state === 'suspended') audioCtx.resume();
    return audioCtx;
  }

  // Light UI click for chest slot selection
  function playClick() {
    const ctx = getCtx();
    const now = ctx.currentTime;

    // Crisp "tock" ‚Äî short noise transient shaped like a mechanical button
    const sr = ctx.sampleRate;
    const len = Math.floor(sr * 0.06);
    const buf = ctx.createBuffer(1, len, sr);
    const d = buf.getChannelData(0);
    for (let i = 0; i < len; i++) {
      const t = i / sr;
      d[i] = (Math.random() * 2 - 1) * Math.exp(-t * 120);
    }
    const src = ctx.createBufferSource();
    src.buffer = buf;

    const bpf = ctx.createBiquadFilter();
    bpf.type = 'bandpass';
    bpf.frequency.value = 2200;
    bpf.Q.value = 2.5;

    const g = ctx.createGain();
    g.gain.setValueAtTime(0.45, now);
    g.gain.exponentialRampToValueAtTime(0.0001, now + 0.06);

    src.connect(bpf); bpf.connect(g); g.connect(ctx.destination);
    src.start(now); src.stop(now + 0.07);

    // Tiny low "tick" body under it
    const o = ctx.createOscillator(), og = ctx.createGain();
    o.type = 'sine';
    o.frequency.setValueAtTime(820, now);
    o.frequency.exponentialRampToValueAtTime(480, now + 0.04);
    og.gain.setValueAtTime(0.12, now);
    og.gain.exponentialRampToValueAtTime(0.0001, now + 0.05);
    o.connect(og); og.connect(ctx.destination);
    o.start(now); o.stop(now + 0.06);
  }

  // Meaty dirt-dig sound for minesweeper reveals
  function playDig() {
    const ctx = getCtx();
    const sr = ctx.sampleRate;
    const now = ctx.currentTime;

    // ‚îÄ‚îÄ MASTER BUS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    const master = ctx.createGain();
    master.gain.value = 1.0;
    master.connect(ctx.destination);

    // ‚îÄ‚îÄ CONVOLUTION REVERB (short cave/room tail) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    const revLen = Math.floor(sr * 0.55);
    const revBuf = ctx.createBuffer(2, revLen, sr);
    for (let ch = 0; ch < 2; ch++) {
      const d = revBuf.getChannelData(ch);
      for (let i = 0; i < revLen; i++) {
        // exponential decay with early reflection spikes
        const t = i / sr;
        const earlyRef = (i < sr * 0.02) ? Math.exp(-t * 60) * 1.4 : 0;
        d[i] = (Math.random() * 2 - 1) * (Math.exp(-t * 7) + earlyRef);
      }
    }
    const reverb = ctx.createConvolver();
    reverb.buffer = revBuf;
    const revGain = ctx.createGain();
    revGain.gain.value = 0.38;
    reverb.connect(revGain);
    revGain.connect(master);

    // ‚îÄ‚îÄ HELPER: send a buffer through the chain ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    function spawnNoise(durationSec, buildFn, lpFreq, lpQ, peakFreq, peakGainDb, gainPeak, gainEnd) {
      const len = Math.floor(sr * durationSec);
      const b = ctx.createBuffer(1, len, sr);
      buildFn(b.getChannelData(0), len, sr);

      const src = ctx.createBufferSource();
      src.buffer = b;

      const lpf = ctx.createBiquadFilter();
      lpf.type = 'lowpass'; lpf.frequency.value = lpFreq; lpf.Q.value = lpQ;

      const peak = ctx.createBiquadFilter();
      peak.type = 'peaking'; peak.frequency.value = peakFreq;
      peak.gain.value = peakGainDb; peak.Q.value = 1.4;

      const g = ctx.createGain();
      g.gain.setValueAtTime(gainPeak, now);
      g.gain.exponentialRampToValueAtTime(0.0001, now + durationSec);

      src.connect(lpf); lpf.connect(peak); peak.connect(g);
      g.connect(master);
      g.connect(reverb); // send to reverb too
      src.start(now); src.stop(now + durationSec + 0.01);
    }

    // ‚îÄ‚îÄ LAYER 1: PUNCHY IMPACT ‚Äî sharp thwack ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    spawnNoise(0.22,
      (d, len, sr) => {
        for (let i = 0; i < len; i++) {
          const t = i / sr;
          d[i] = (Math.random() * 2 - 1) * (Math.exp(-t * 45) + Math.exp(-t * 12) * 0.5);
        }
        // pebble pops scattered in first 80ms
        [0.003, 0.014, 0.028, 0.048, 0.072].forEach(ct => {
          const ci = Math.floor(ct * sr);
          for (let k = 0; k < Math.floor(sr * 0.007); k++)
            if (ci + k < len)
              d[ci + k] += (Math.random() * 2 - 1) * Math.exp(-k / (sr * 0.0025)) * 1.1;
        });
      },
      1100, 1.1, 220, 11, 1.1, 0.001
    );

    // ‚îÄ‚îÄ LAYER 2: CRUNCH TAIL ‚Äî longer gritty rumble ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    spawnNoise(0.28,
      (d, len, sr) => {
        for (let i = 0; i < len; i++) {
          const t = i / sr;
          d[i] = (Math.random() * 2 - 1) * Math.exp(-t * 9) * 0.7;
        }
      },
      600, 0.9, 150, 8, 0.7, 0.001
    );

    // ‚îÄ‚îÄ LAYER 3: SUB THUD ‚Äî satisfying low body ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    const subOsc = ctx.createOscillator();
    const subGain = ctx.createGain();
    subOsc.type = 'sine';
    subOsc.frequency.setValueAtTime(95, now);
    subOsc.frequency.exponentialRampToValueAtTime(38, now + 0.14);
    subGain.gain.setValueAtTime(0.55, now);
    subGain.gain.exponentialRampToValueAtTime(0.0001, now + 0.18);
    subOsc.connect(subGain);
    subGain.connect(master);
    subGain.connect(reverb);
    subOsc.start(now); subOsc.stop(now + 0.19);

    // ‚îÄ‚îÄ LAYER 4: HARMONIC BODY ‚Äî gives it earthy "wood/stone" tone ‚îÄ‚îÄ
    const bodyOsc = ctx.createOscillator();
    const bodyGain = ctx.createGain();
    bodyOsc.type = 'triangle';
    bodyOsc.frequency.setValueAtTime(200, now);
    bodyOsc.frequency.exponentialRampToValueAtTime(110, now + 0.09);
    bodyGain.gain.setValueAtTime(0.22, now);
    bodyGain.gain.exponentialRampToValueAtTime(0.0001, now + 0.12);
    bodyOsc.connect(bodyGain);
    bodyGain.connect(master);
    bodyGain.connect(reverb);
    bodyOsc.start(now); bodyOsc.stop(now + 0.13);
  }

  function playFlag(placing) {
    const ctx = getCtx();
    if (placing) {
      // Thwip up + thud
      const o1 = ctx.createOscillator(), g1 = ctx.createGain();
      o1.connect(g1); g1.connect(ctx.destination);
      o1.type = 'square';
      o1.frequency.setValueAtTime(200, ctx.currentTime);
      o1.frequency.exponentialRampToValueAtTime(800, ctx.currentTime + 0.07);
      g1.gain.setValueAtTime(0.2, ctx.currentTime);
      g1.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.09);
      o1.start(); o1.stop(ctx.currentTime + 0.1);

      const o2 = ctx.createOscillator(), g2 = ctx.createGain();
      o2.connect(g2); g2.connect(ctx.destination);
      o2.type = 'sine';
      o2.frequency.setValueAtTime(120, ctx.currentTime + 0.05);
      o2.frequency.exponentialRampToValueAtTime(50, ctx.currentTime + 0.18);
      g2.gain.setValueAtTime(0.35, ctx.currentTime + 0.05);
      g2.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.2);
      o2.start(ctx.currentTime + 0.05); o2.stop(ctx.currentTime + 0.21);
    } else {
      // Descending whoosh = removal
      const o = ctx.createOscillator(), g = ctx.createGain();
      o.connect(g); g.connect(ctx.destination);
      o.type = 'triangle';
      o.frequency.setValueAtTime(700, ctx.currentTime);
      o.frequency.exponentialRampToValueAtTime(180, ctx.currentTime + 0.1);
      g.gain.setValueAtTime(0.18, ctx.currentTime);
      g.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.12);
      o.start(); o.stop(ctx.currentTime + 0.13);
    }
  }

  function playTab() {
    const ctx = getCtx();
    // Crispy percussive "tock" using filtered noise
    const buf = ctx.createBuffer(1, Math.floor(ctx.sampleRate * 0.05), ctx.sampleRate);
    const data = buf.getChannelData(0);
    for (let i = 0; i < data.length; i++)
      data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (ctx.sampleRate * 0.007));
    const src = ctx.createBufferSource();
    const filt = ctx.createBiquadFilter();
    const g = ctx.createGain();
    filt.type = 'bandpass'; filt.frequency.value = 1400; filt.Q.value = 2.5;
    src.buffer = buf;
    src.connect(filt); filt.connect(g); g.connect(ctx.destination);
    g.gain.setValueAtTime(0.7, ctx.currentTime);
    src.start(); src.stop(ctx.currentTime + 0.06);
  }

  function playDeath() {
    const ctx = getCtx();
    [[0, 300, 250, 0.18], [0.22, 250, 200, 0.18], [0.44, 200, 160, 0.18], [0.66, 160, 80, 0.55]]
      .forEach(([t, f0, f1, dur]) => {
        const o = ctx.createOscillator(), g = ctx.createGain();
        o.connect(g); g.connect(ctx.destination);
        o.type = 'sawtooth';
        o.frequency.setValueAtTime(f0, ctx.currentTime + t);
        o.frequency.exponentialRampToValueAtTime(f1, ctx.currentTime + t + dur);
        g.gain.setValueAtTime(0.3, ctx.currentTime + t);
        g.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + t + dur + 0.05);
        o.start(ctx.currentTime + t); o.stop(ctx.currentTime + t + dur + 0.06);
      });
  }

  function playReset() {
    const ctx = getCtx();
    [523, 659, 784, 1047].forEach((freq, i) => {
      const o = ctx.createOscillator(), g = ctx.createGain();
      o.connect(g); g.connect(ctx.destination);
      o.type = 'square';
      const t = ctx.currentTime + i * 0.1;
      o.frequency.setValueAtTime(freq, t);
      g.gain.setValueAtTime(0.15, t);
      g.gain.exponentialRampToValueAtTime(0.001, t + 0.18);
      o.start(t); o.stop(t + 0.19);
    });
  }

  function playWin() {
    const ctx = getCtx();
    const o = ctx.createOscillator(), g = ctx.createGain();
    o.connect(g); g.connect(ctx.destination);
    o.type = 'sine';
    o.frequency.setValueAtTime(400, ctx.currentTime);
    o.frequency.exponentialRampToValueAtTime(1600, ctx.currentTime + 0.5);
    g.gain.setValueAtTime(0.3, ctx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.55);
    o.start(); o.stop(ctx.currentTime + 0.56);
    [0.55, 0.65, 0.75].forEach((t, i) => {
      const o2 = ctx.createOscillator(), g2 = ctx.createGain();
      o2.connect(g2); g2.connect(ctx.destination);
      o2.type = 'triangle';
      o2.frequency.value = [1047, 1319, 1568][i];
      g2.gain.setValueAtTime(0.2, ctx.currentTime + t);
      g2.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + t + 0.15);
      o2.start(ctx.currentTime + t); o2.stop(ctx.currentTime + t + 0.16);
    });
  }

  // ‚îÄ‚îÄ‚îÄ CHEST ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const chestSelected = new Set();

  function updateChestLabel() {
    const label = document.getElementById('selected-label');
    if (chestSelected.size === 0) {
      label.textContent = 'Selected chest slots: none | Total: 0';
    } else {
      const sorted = [...chestSelected].sort((a, b) => a - b);
      label.textContent = 'Selected chest slots: ' + sorted.join(', ') + ' | Total: ' + sorted.length;
    }
  }

  function clearChestSelection() {
    chestSelected.clear();
    document.querySelectorAll('#chest-grid .slot.selected').forEach(s => s.classList.remove('selected'));
    updateChestLabel();
  }

  const CHEST_CONFIGS = {
    large:  { slots: 54, cols: 9, label: 'Large Chest' },
    small:  { slots: 27, cols: 9, label: 'Small Chest' },
    hopper: { slots: 5,  cols: 5, label: 'Hopper' },
  };
  let currentTab = 'large';

  function switchTab(type) {
    if (type === currentTab) return;
    playTab();
    currentTab = type;
    chestSelected.clear();
    updateChestLabel();
    ['large', 'small', 'hopper'].forEach(t =>
      document.getElementById('tab-' + t).classList.toggle('active', t === type)
    );
    buildChestGrid();
  }

  function buildChestGrid() {
    const cfg = CHEST_CONFIGS[currentTab];
    const chestGrid = document.getElementById('chest-grid');
    chestGrid.innerHTML = '';
    chestGrid.style.gridTemplateColumns = `repeat(${cfg.cols}, var(--cell))`;
    chestGrid.style.justifyContent = currentTab === 'hopper' ? 'center' : 'start';
    document.getElementById('chest-label').textContent = cfg.label;
    for (let i = 0; i < cfg.slots; i++) {
      const slot = document.createElement('div');
      slot.className = 'slot';
      slot.textContent = i;
      slot.addEventListener('click', () => {
        playClick();
        slot.classList.toggle('selected');
        chestSelected.has(i) ? chestSelected.delete(i) : chestSelected.add(i);
        updateChestLabel();
      });
      chestGrid.appendChild(slot);
    }
  }

  buildChestGrid();

  const hotbarGrid = document.getElementById('hotbar-grid');
  hotbarGrid.style.gridTemplateColumns = 'repeat(9, var(--cell))';
  for (let i = 0; i < 9; i++) {
    const s = document.createElement('div');
    s.className = 'slot';
    s.style.cursor = 'default';
    hotbarGrid.appendChild(s);
  }

  // ‚îÄ‚îÄ‚îÄ MINESWEEPER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const ROWS = 9, COLS = 9, TOTAL_MINES = 12;
  const LONG_PRESS_MS = 500;

  // ‚îÄ‚îÄ‚îÄ TOOL SWITCHER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  let flagMode = false;

  function setTool(tool) {
    flagMode = (tool === 'flag');
    const digBtn  = document.getElementById('tool-dig');
    const flagBtn = document.getElementById('tool-flag');
    const hint    = document.getElementById('tool-hint');
    const msGrid  = document.getElementById('ms-grid');
    digBtn.className  = 'tool-btn' + (flagMode ? '' : ' active-dig');
    flagBtn.className = 'tool-btn' + (flagMode ? ' active-flag' : '');
    if (flagMode) {
      msGrid.classList.add('flag-mode');
      hint.textContent = 'tap to flag ¬∑ right-click to dig';
    } else {
      msGrid.classList.remove('flag-mode');
      hint.textContent = 'tap to dig ¬∑ hold/right-click to flag';
    }
    playTab();
  }

  let board = [], gameOver = false, gameWon = false,
      firstClick = true, flagCount = 0,
      timerVal = 0, timerInterval = null;

  function resetGame() {
    clearInterval(timerInterval);
    playReset();
    timerVal = 0; gameOver = false; gameWon = false;
    firstClick = true; flagCount = 0;
    document.getElementById('mine-counter').textContent = String(TOTAL_MINES).padStart(3, '0');
    document.getElementById('timer-display').textContent = '000';
    document.getElementById('face-btn').textContent = '(‚ïπ⁄°‚ïπ )';
    initBoard(); renderBoard();
  }

  function initBoard() {
    board = [];
    for (let r = 0; r < ROWS; r++) {
      board[r] = [];
      for (let c = 0; c < COLS; c++)
        board[r][c] = { mine: false, revealed: false, flagged: false, count: 0 };
    }
  }

  function placeMines(safeR, safeC) {
    const safe = new Set();
    for (let dr = -1; dr <= 1; dr++)
      for (let dc = -1; dc <= 1; dc++) {
        const nr = safeR+dr, nc = safeC+dc;
        if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS) safe.add(nr*COLS+nc);
      }
    let placed = 0;
    while (placed < TOTAL_MINES) {
      const r = Math.floor(Math.random()*ROWS), c = Math.floor(Math.random()*COLS);
      if (!board[r][c].mine && !safe.has(r*COLS+c)) { board[r][c].mine = true; placed++; }
    }
    for (let r = 0; r < ROWS; r++)
      for (let c = 0; c < COLS; c++)
        if (!board[r][c].mine) board[r][c].count = countNeighborMines(r, c);
  }

  function countNeighborMines(r, c) {
    let n = 0;
    for (let dr = -1; dr <= 1; dr++)
      for (let dc = -1; dc <= 1; dc++) {
        const nr=r+dr, nc=c+dc;
        if (nr>=0&&nr<ROWS&&nc>=0&&nc<COLS&&board[nr][nc].mine) n++;
      }
    return n;
  }

  function reveal(r, c) {
    if (r<0||r>=ROWS||c<0||c>=COLS) return;
    const cell = board[r][c];
    if (cell.revealed || cell.flagged) return;
    cell.revealed = true;
    if (cell.count === 0 && !cell.mine)
      for (let dr=-1;dr<=1;dr++) for (let dc=-1;dc<=1;dc++) reveal(r+dr,c+dc);
  }

  function checkWin() {
    for (let r=0;r<ROWS;r++) for (let c=0;c<COLS;c++)
      if (!board[r][c].mine && !board[r][c].revealed) return false;
    return true;
  }

  function handleClick(r, c) {
    if (gameOver || gameWon) return;
    const cell = board[r][c];
    if (cell.revealed || cell.flagged) return;

    if (firstClick) {
      firstClick = false;
      placeMines(r, c);
      timerInterval = setInterval(() => {
        timerVal = Math.min(timerVal+1, 999);
        document.getElementById('timer-display').textContent = String(timerVal).padStart(3,'0');
      }, 1000);
    }

    if (cell.mine) {
      cell.revealed = true; gameOver = true;
      clearInterval(timerInterval);
      playDeath();
      document.getElementById('face-btn').textContent = "(‚î¨‚î¨Ôπè‚î¨‚î¨)";
      revealAllMines(r, c); renderBoard(); return;
    }

    reveal(r, c);
    playDig();

    if (checkWin()) {
      gameWon = true; clearInterval(timerInterval);
      playWin();
      document.getElementById('face-btn').textContent = "~\\(‚âß‚ñΩ‚â¶)/~";
      for (let rr=0;rr<ROWS;rr++) for (let cc=0;cc<COLS;cc++)
        if (board[rr][cc].mine) board[rr][cc].flagged = true;
      flagCount = TOTAL_MINES;
      document.getElementById('mine-counter').textContent = '000';
    }
    renderBoard();
  }

  function handleFlag(r, c) {
    if (gameOver || gameWon) return;
    const cell = board[r][c];
    if (cell.revealed) return;
    if (!cell.flagged && flagCount >= TOTAL_MINES) return;
    cell.flagged = !cell.flagged;
    flagCount += cell.flagged ? 1 : -1;
    playFlag(cell.flagged);
    document.getElementById('mine-counter').textContent =
      String(Math.max(0, TOTAL_MINES - flagCount)).padStart(3,'0');
    renderBoard();
  }

  function revealAllMines(hitR, hitC) {
    for (let r=0;r<ROWS;r++) for (let c=0;c<COLS;c++) {
      const cell = board[r][c];
      if (cell.mine && !(r===hitR&&c===hitC)) cell.revealed = true;
      if (!cell.mine && cell.flagged) cell.wrongFlag = true;
    }
  }

  const NUM_COLORS = ['','#1111cc','#117711','#cc1111','#111177','#771111','#117777','#111111','#777777'];

  function renderBoard() {
    const grid = document.getElementById('ms-grid');
    grid.innerHTML = '';
    for (let r=0;r<ROWS;r++) for (let c=0;c<COLS;c++) {
      const cell = board[r][c];
      const el = document.createElement('div');
      el.className = 'ms-cell';

      if (cell.revealed) {
        if (cell.mine) { el.classList.add('mine-hit'); el.textContent = 'üí£'; }
        else {
          el.classList.add('revealed');
          if (cell.count > 0) { el.textContent = cell.count; el.style.color = NUM_COLORS[cell.count]; }
        }
      } else if (cell.flagged) {
        el.classList.add('flagged'); el.textContent = 'üö©';
      } else if (cell.wrongFlag) {
        el.classList.add('revealed'); el.textContent = '‚ùå';
      } else {
        el.classList.add('hidden');
      }

      const rr=r, cc=c;

      // Desktop: right-click always flags regardless of mode
      el.addEventListener('click', () => {
        if (flagMode) handleFlag(rr, cc);
        else handleClick(rr, cc);
      });
      el.addEventListener('contextmenu', e => {
        e.preventDefault();
        if (flagMode) handleClick(rr, cc);
        else handleFlag(rr, cc);
      });

      // Mobile: in dig mode ‚Äî tap=dig, hold=flag
      //         in flag mode ‚Äî tap=flag, hold=dig
      let pressTimer = null, didLongPress = false;

      el.addEventListener('touchstart', e => {
        e.preventDefault();
        if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
        didLongPress = false;
        if (!cell.revealed) el.classList.add('pressing');
        pressTimer = setTimeout(() => {
          didLongPress = true;
          el.classList.remove('pressing');
          // Long press = opposite of current mode
          if (flagMode) handleClick(rr, cc);
          else handleFlag(rr, cc);
        }, LONG_PRESS_MS);
      }, { passive: false });

      el.addEventListener('touchend', e => {
        e.preventDefault();
        clearTimeout(pressTimer);
        el.classList.remove('pressing');
        if (!didLongPress) {
          // Tap = current mode
          if (flagMode) handleFlag(rr, cc);
          else handleClick(rr, cc);
        }
      }, { passive: false });

      el.addEventListener('touchmove', e => {
        clearTimeout(pressTimer);
        el.classList.remove('pressing');
        didLongPress = true; // cancel action on scroll
      }, { passive: false });

      grid.appendChild(el);
    }
  }

  resetGame();
</script>
</body>
</html>
